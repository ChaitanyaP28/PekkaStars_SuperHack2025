""" Code generated by the LLM as displayed in the demo """
import os
import asyncio
import websockets
import time

from datetime import datetime
from threading import Thread, Event

from dotenv import load_dotenv
load_dotenv()

LOG_FILE = "log.txt"
LOG_MODE = "a"

WS_HOST = os.getenv("WS_HOST")
WS_PORT = os.getenv("WS_PORT")

APP_HOST = os.getenv("APP_HOST")
APP_PORT = os.getenv("APP_PORT")

HB_HOST = os.getenv("HB_HOST")
HB_PORT = os.getenv("HB_PORT")

APPSOCKET_URI = f"ws://{APP_HOST or 'localhost'}:{APP_PORT or '8001'}"
WEBSOCKET_URI = f"ws://{WS_HOST or 'localhost'}:{WS_PORT or '8000'}"
HB_URI = f"ws://{HB_HOST or 'localhost'}:{HB_PORT or '8002'}"

APP_ID = "read-from-serv"
APP_NAME = "2.py"

hb_stop = Event()
hb_thread = None

async def send_heartbeats():
    global hb_stop
    while not hb_stop.is_set():
        try:
            async with websockets.connect(HB_URI) as ws:
                hb_line = f"[{APP_ID}] [INFO] [{datetime.now().isoformat()}] Heartbeat"
                await ws.send(hb_line)
        except Exception as e:
            log(f"Heartbeat connection error: {e}", sev="INFO")
        await asyncio.sleep(1)

def hb_thread_wrapper():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        loop.run_until_complete(send_heartbeats())
    finally:
        loop.close()

async def get_app_id():
    global APP_ID
    try:
        async with websockets.connect(APPSOCKET_URI) as ws:
            await ws.send(f"{APP_NAME}")
            APP_ID = await ws.recv()
    except Exception as e:
        log(f"Failed to get APP_ID: {e}. Using default: {APP_ID}", sev="INFO")

def init():
    global APP_ID
    global hb_thread
    global LOG_MODE
    asyncio.run(get_app_id())
    if os.path.exists(LOG_FILE):
        log(f"Application 2.py restarted with UUID: {APP_ID}")
    else:
        LOG_MODE = "w"
        log(f"Application 2.py started with UUID: {APP_ID}")
        LOG_MODE = "a"
    hb_thread = Thread(target=hb_thread_wrapper, daemon=True)
    hb_thread.start()

async def rm_app_id():
    global APP_ID
    try:
        async with websockets.connect(HB_URI) as ws:
            rm_line = f"[{APP_ID}] [INFO] [{datetime.now().isoformat()}] Exit"
            await ws.send(rm_line)
    except Exception as e:
        log(f"Failed to send exit signal: {e}", sev="INFO")

def deinit():
    global hb_stop
    global hb_thread
    hb_stop.set()
    if hb_thread and hb_thread.is_alive():
        hb_thread.join(timeout=2)
        if hb_thread.is_alive():
            log("Heartbeat thread did not terminate gracefully.", sev="INFO")
    try:
        asyncio.run(rm_app_id())
    except Exception as e:
        log(f"Error during rm_app_id in deinit: {e}", sev="INFO")

async def stream(log_line):
    try:
        async with websockets.connect(WEBSOCKET_URI) as ws:
            await ws.send(f"[{APP_NAME}] {log_line}")
    except Exception as e:
        print(f"[{APP_NAME}] [INFO] [{datetime.now().isoformat()}] Failed to stream log: {e} - Original log: {log_line.strip()}")

def log(msg, sev="INFO", ts=datetime.now().isoformat()):
    log_line = f"[{sev}] [{ts}] {msg}\n"
    # with open(LOG_FILE, LOG_MODE) as f:
    #     f.write(log_line)
    #     f.flush()
    try:
        asyncio.run(stream(log_line))
    except Exception as e:
        print(f"[{APP_NAME}] [INFO] [{datetime.now().isoformat()}] Failed to setup log stream: {e} - Original log: {log_line.strip()}")

def info(msg):
    log(msg, sev="INFO")

def error(msg):
    log(msg, sev="INFO")

if __name__ == "__main__":
    init()
    time.sleep(1)
    info("Division Program Started")
    
    try:
        a_str = input("Enter first number (a): ")
        log(f"User entered a = {a_str}")
        
        b_str = input("Enter second number (b): ")
        log(f"User entered b = {b_str}")
        
        a = float(a_str)
        b = float(b_str)
        
        result = a / b
        print(f"Result: {a} / {b} = {result}")
        info(f"Result: {a} / {b} = {result}")
        time.sleep(1)
        log("Application 2.py completed successfully")
    except ZeroDivisionError as e:
        info(f"Division by zero error: {str(e)}")
    except ValueError as e:
        info(f"Invalid input error: {str(e)}")
    except Exception as e:
        info(f"Unexpected error: {str(e)}")
    finally:
        deinit()